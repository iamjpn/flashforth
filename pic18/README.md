# PIC18

## Terms
Program Memory = Instruction Memory = FLASH
Data Memory = RAM 
EEPROM 

## Notes
* kB here is 2^10 bytes.
FlashForth uses memory from 0 - 0xFFFF. 
This range is split between Program Memory, Data Memory and EEPROM Memory. 
How this is handled will be discussed latter. 

## Configuration
Major Configuartions are in Important Files/p18f-main.cfg
p18fxxxx.cfg used to select which of the other .cfg will be used to set controller specific options. 
It also defines memory locations used by FF. 
These are FLASH_HI, EEPROM_HI and RAM_HI. 
As far as I can tell these are only used for the ```hi''' instruction. 

The processor type is defined in FILE->Project Properties Configuration Device.

Example: 
The Project Device is configured to PIC18F26K22. 
Hence p18fxxxx.cfg:513 is true.

The three high memory locations are given as 
#define FLASH_HI  0xebff
#define EEPROM_HI 0xefff
#define RAM_HI    0xff37

How are these values determined?
The easiest way is to work backwades. 
Open up the data sheet for the K22. 
FIGURE 5-8 on Page 75 shows the Data Memory Map. 
The special function registers (SFR) begin at 0xf37. 
Clearly the can not be used as general purpose data memory so it makes sense to stop here. 
But RAM_HI is 0xff37 not 0xf37. Where did the extra 0xf000 come from?
This is to do with FlashForth unifying RAM, Program and Flash into a single address space.   
At ff-pic18.asm:147 memory mapping prefixes are defined. 
RAM is given an offset of 0xF000 called PRAM. 

Looking at the EEPROM_HI, how is this value arrived at?
It is the byte before the start of the RAM. 
In a similar way the start of the RAM is defined with the offset PEEPROM with a value of 0xce00
FLASH_HI is then simply the byte before the EEPROM starts. 

In the p18f2x4xk22.cfg file a few things happen. 
First the processor configuration bits are set. 
This can be generated by MPLAB. 
Another part of interest are the constants for controlling writes to the flash:
    * flash_write_outer_loop
    * flash_write_inner_loop

## Storing and Writing 
We have these three different memory locations, so how are is writing and reading from all of them handled by flash forth. 



## Writing to the Flash / Instruction Memory 


## The Flash buffer
We need the flash buffer because of how PIC18 write to the program memory. 
I've been wrong in my assumptions. 
The flash buffer is not to speed things up or anything like that.
It is literally what they are talking about when they talk about writing in blocks. 
As we write in blocks, we use the MSBs to select what block we are talking about.  
If we check with the mask to see if the byte we are trying to update is in the block we have in memory. 
If it is not, we see if we made any changes to the block in RAM that arn't on the disk. 
If we did, then write those changes to the memory. 
Then set the base to the MSBs to identify our new block,  


The Flash buffer is defined with the other internel variables ff-pic18.asm:157. 
```
FLASH_BUF udata_acs
flash_buf res 0x40
```
The first thing to notice is that it is begining an access data section called FLASH_BUF. 
As no address is provided, the location will be determined at link time. 
To recap Access Ram, remeber the PIC18 uses an banks to reach the entire range of data memory. 
The user is responsible for ensuring the correct bank is seleceted. 
This gets tedious and error prone, there is an Access Bank which can be accessed without selecting a bank. 
The Access bank contains 0x00-0x5F from Bank 0 (96 bytes) and 0x60-0xFF from Block 15 (160 bytes). 
The lower section are general purpose regisitors, so this section is called Access Ram. 
Instructions can be modified to use the Access Ram and disregard the selected bank. 
This is done using the Acess RAM bit of instructions, the 'a' parameter. 

So FlashForth is reserving 0x40 bytes of access ram. 
But where does this reservation begin? 
As mentioned, this is determined at the linking step. 
FlashForth distributes it's own linking script FF_0000.lkr. 
At FF_0000.lkr:16 the position of the FLASH_BUF is set. 
```
ACCESSBANK NAME=flashbuf   START=0x0            END=0x3F           PROTECTED
```
So it is using up the first 0x40 bytes of the Acess RAM.  


In FORTH_VARS a couple of pairs of variables related to the Flash Buffer are defined.   
Remeber i- is talking about instruction memory. 
There is:
    *ibase_lo Memory address of ibuffer
    *ibase_hi
    *iaddr_lo Instruction Memory access address
    *iaddr_hi
The descriptions are a little vague, let us see how they are used.  
ibase_lo and ibase_hi are used in iupdatebuf, iupdatebuff0, init_ptrs, IFETCH, ICFETCH1
ibase_hi is also used in verify_imem_1, WARM_ZER0_1
iaddr_lo and iaddr_hi are used in iupdatebuf, iupdatebuf0, ISTORE_SETUP

So lets have a look at what these labels are doing to understand how the buffer is used. Starting with iupdatebuff we
have this comment at the top: 
```
;if (ibaselo != (iaddrlo&0xc0))&& (ibasehi != iaddrhi)
;   if (idirty)
;       writebuffer_to_imem
;   endif
;   fillbuffer_from_imem
;   ibaselo = iaddrlo&0xc0
;   ibasehi = iaddrhi
;endif
```

To make sense of this, we should first talk about how the PIC18 reads to and writes from program memory. 
* Read one byte at a time
* Write 64 bytes at a time
* Erase 64 bytes at a time


To achieve this there is the Table Read (TBLRD) and Table Write (TBLWT). 
Both of these move data between Flash and Ram through the TABLAT 8bit register. 
Additionally EECON1 and EECON2 control the write processes. 
The Table Pointer TBLPTR addresses a byte in the program memory. 
It is comprised of TBLPTRU:TBLPTRH:TBLPTRL which act as a 22bit pointer. 
The bottom 21 bits are used to act as pointers. 

As mentioned, writing acts on multiple bytes at a time. 
The MSBs determine the position that the block should be written too. 
 

## Overall storing / reading
Here we see the effect of the memory model. 
Forth has the `!' ( x addr -- ) word to put a value into an address. 
But we need a bit of shuffling to make this work with values saved in multiple places. 
This is happening at ff-pic18.asm:2523.

```
STORE:
        movlw   PRAM>>8 ; 0xf000 >> 8 = 0xf0. So this value now in Working
        cpfslt  Srw, A ; Compare f with W, skip if f < W. Srw, reads the top of stack 
        bra     STORE1
        movlw   PEEPROM>>8
        cpfslt  Srw, A
        bra     ESTORE
        bra     ISTORE
STORE1:
        movff   Sminus, Tbank
        movff   Sminus, Tp
        swapf   Tplus, W, A
        movff   Sminus, Tminus
        movff   Sminus, Trw
return1:
        return
```

* Order:
flash
eeprom
sram

Remeber 8bit wide datapath, so what we get first is the top of the stack, 
hence we see what is happening here, with things only effecting the msbs
store(val, addr) {
    if (addr < PRAM>>8) { //0xf000 >> 8 = 0xf0
        if (addr < PEEPROM>>8 ) { // 0xec00 = 0xec 
            ISTORE
        } else {
            ESTORE 
        }
    } else {
        // STORE 1
        ; popping twice of the paramater stack, to put the address into the redirect registers
        movff   Sminus, Tbank ;; FSR1H
        movff   Sminus, Tp ;; FSR1L 
        ; The upper and lower nibbles of register ‘f’ are exchanged
        swapf   Tplus, W, A ;; POSTINC1, placed in working 
        movff   Sminus, Tminus ;; POP
        movff   Sminus, Trw ;; INDF1
    }

}

It is important to note that on the PIC18s the FSR registor pairs hold a 12 bit value. 
The upper 4bits of FSR1H are not used. 
Not that this is the 0xf000 offset that is applied in flashforth. 


### Storing in the Instruction Memory 
So if we have an addr less then the EEPROM, it will go in the instruction memory
```
; I!       x a-addr --    store cell in Code mem
ISTORE:
        rcall   ISTORE_SETUP
        movff   Sminus, plusT
        swapf   Tminus, W, A

        bra     ICSTORE1

ISTORE_SETUP:
        rcall   LOCKED
; check that writes are not to the kernel code
        rcall   ISTORECHK
;check if program memory row is already in buffer
        movff   Sminus, iaddr_hi
        movff   Sminus, iaddr_lo
        rcall   iupdatebuf
;write_cell_to_buffer
        movf    iaddr_lo, W, A
        andlw   0x3f
        lfsr    Tptr, flash_buf
        addwf   Tp, F, A
        return

;;;
LOCKED:
        btfss   FLAGS1, fLOCK
        return
        bra     ISTORERR

ISTORERR:
        call    DOTS
        rcall   XSQUOTE
        db      3,"AD?"
        rcall   TYPE
        bra     STARTQ2        ; goto    ABORT

ISTORECHK:
#if XSTORE == ENABLE
        tstfsz  iaddr_up, A
        return
#else
        movlw   HIGH FLASH_HI+1
        cpfslt  Srw, A
        bra     ISTORERR
#endif
        movlw   HIGH dpcode ;(dp_user_dictionary>>8) ;
        cpfslt  Srw, A
        return
        bra     ISTORERR

; *******************************************************************
;if (ibaselo != (iaddrlo&0xc0))&& (ibasehi != iaddrhi)
;   if (idirty)
;       writebuffer_to_imem
;   endif
;   fillbuffer_from_imem
;   ibaselo = iaddrlo&0xc0
;   ibasehi = iaddrhi
;endif
iupdatebuf:
#if XSTORE == ENABLE
        movf    iaddr_up, W, A
        cpfseq  ibase_up, A
        bra     iupdatebuf0
#endif
        movf    iaddr_hi, W, A
        cpfseq  ibase_hi
        bra     iupdatebuf0
        movlw   h'c0'
        andwf   iaddr_lo, W, A
        cpfseq  ibase_lo, A
        bra     iupdatebuf0
        return

iupdatebuf0:
        rcall   IFLUSH
        movlw   h'c0'
        andwf   iaddr_lo, W, A
        movwf   ibase_lo, A
        movff   iaddr_hi, ibase_hi
#if XSTORE == ENABLE
        movff   iaddr_up, ibase_up
#endif
fill_buffer_from_imem:
        movlw   d'64'
        movwf   PCLATH, A
        rcall   init_ptrs             ; Init TBLPTR and ram pointer
fill_buffer_from_imem_1:
        tblrd*+
        movff   TABLAT, Tplus
        decfsz  PCLATH, F, A
        bra     fill_buffer_from_imem_1
#if XSTORE == ENABLE
        clrf    TBLPTRU, A
#endif
        return

L_IFLUSH:
        db      NFA|6,"iflush"
IFLUSH:
        btfsc   FLAGS1, idirty, A
        bra     write_buffer_to_imem
        return

write_buffer_to_imem:
;; Loop here until there are no more characters has been received for a while
;; from the UART.
;; The assumption is that the serial line is silent then.
#ifdef OPERATOR_RX_IS_UART
#if FC_TYPE_SW == ENABLE
        btfss   FLAGS2, fFC, A
        rcall   XXXOFF
#endif
#ifdef  HW_FC_CTS_PORT
        btfss   FLAGS2, fFC, A
        bsf     HW_FC_CTS_PORT, HW_FC_CTS_PIN, A
#endif

wbtil:
        bcf     FLAGS1, istream, A
        movlw   write_delay   ;  This loop takes about 20 milliseconds
        movwf   Tbank, A
wbtil1:
        clrf    Tp, A
wbtil2: 
        btfsc   FLAGS1, istream, A ; Check for UART receive activity.
        bra     wbtil
        decfsz  Tp, F, A
        bra     wbtil2             ; 1250 cycles = 78 us @ 64 MHz XTAL 
        decfsz  Tbank, F, A
        bra     wbtil1             ; 20 ms @ 64 MHz XTAL @ write_delay = 255
#endif
        bcf     INTCON, GIE, A  ; Disable Interrupts

#ifdef p18fxx2xx8_fix_1
        movff   PIE1, SPIE1
        movff   PIE2, SPIE2
        movff   INTCON, SINTCON ; TMR0IF, INT0IF, RBIF 
        clrf    INTCON, A       ; may be lost
        clrf    PIE1, A
        clrf    PIE2, A
#endif
        rcall   init_ptrs             ; Init TBLPTR and ram pointer
        bsf     EECON1, EEPGD, A      ; Erase the flash block
        bcf     EECON1, CFGS, A
        bsf     EECON1, WREN, A
        bsf     EECON1, FREE, A

        rcall   magic

        TBLRD*-

        movlw   flash_write_outer_loop
        movwf   PRODH, A
write_buffer_to_imem_1:
        movlw   flash_write_inner_loop
        movwf   PRODL, A
write_buffer_to_imem_2:
        movf    Tplus, W, A
        movwf   TABLAT, A
        tblwt+*
        decfsz  PRODL, F, A
        bra     write_buffer_to_imem_2
        rcall   magic
        decfsz  PRODH, F, A
        bra     write_buffer_to_imem_1
        bcf     EECON1, WREN, A

#ifdef p18fxx2xx8_fix_1
        movff   SPIE2, PIE2
        movff   SPIE1, PIE1
        movff   SINTCON, INTCON
#endif
        bsf     INTCON, GIE, A        
verify_imem:
        movlw   d'64'
        movwf   PCLATH, A
        rcall   init_ptrs
verify_imem_1:
        tblrd*+
        movf    TABLAT, W
        cpfseq  Tplus, A
        reset
        decfsz  PCLATH, F, A
        bra     verify_imem_1

        bcf     FLAGS1, idirty, A ; Mark flash buffer clean
        setf    ibase_hi, A ; Mark flash buffer empty
#if XSTORE == ENABLE
        setf    ibase_up, A ; Mark flash buffer empty
	    clrf    TBLPTRU
#endif
        return
init_ptrs:
        lfsr    Tptr, flash_buf
        movff   ibase_lo, TBLPTRL
        movff   ibase_hi, TBLPTRH
#if XSTORE == ENABLE
        movff   ibase_up, TBLPTRU
#endif
        return
magic:
        movlw   h'55'
        movwf   EECON2, A
        movlw   h'aa'
        movwf   EECON2, A
        bsf     EECON1, WR, A
        return

ICSTORE1:
        movff   Sminus, Trw
;mark_buffer_dirty
        bsf     FLAGS1, idirty, A
        return


## Allocating memory to the user 
The user dictionary in Forth holds not only words, but will also be used to hold variables or other information. 
This is complicated a little bit in FlashForth as we have multiple memory contexts. 

```
;;; EMPTY dictionary data
STARTV: dw      h'0000'
DPC:    dw      dpcode     ; dp_user_dictionary dpcode is right at the end, seems to just load up 0xffff
DPE:    dw      dpeeprom
DPD:    dw      dpdata+h'f000'
LW:     dw      lastword
STAT:   dw      DOTSTATUS
```



# Linker
How are the sizes calculated?

## Stacks in PIC
The PIC18 microcontrollers do not have a hardware stack. 
To get around this we use the 3 File Select Registers (FSR) the PIC18 has. 
The FSR provide indirect addressing. 
What is indirect addressing? First consider direct addressing. 
This is what is seen in the asm instructions that take a register address as an operand.
As it is part of an instruction and so will be compiled into the program memory, we can not easily change the reister address if we wanted to use a different register.  
Indirect addressing, and hence FSR provide a solution to this problem. 
The FSRs act as pointers to memory locations so by changing the address in the FSR it is possible to change which
registor will be accessed. 
To make use of the FSRs, there are virtual registers. 
The INDF register when used in an instruction will actually use the address in the FSR.  
That is to say that reading from INDF is the same as reading from the registor held in the corresponding FSR. 
There are a few other virtual registers available, which increment and decrement the value held in the FSR. 
This is what we need for our stacks, all we need is a region of memory dedicated for it.  

## The case of the missing BANKSEL
You might be wondering why there are no BANKSEL directives in the entire code base. 
Answer, indirect access and MOVFF

## Name Field
Forth keeps its entries in a linked list, contains a name of flags, which can give information about certain aspects of
the word. 
COMPILE: Some words only used at compile time 
NFA: Name field address, start of the name
IMMED: At compile time when seen by compiler
INLINE: Will not be threaded


## de Declare EEPROM DATA BYTE
EEPROM start address is 0xF00000 for PIC18, this is mapped to 000 in eeprom 
